func p int.
func trig.
func q int.
func trig1.

func acc int.
func acc1 int.

func tester string, list prop, int.
tester Str Ctx Var :-
  print "In" Str "ctx is" Ctx,
  print "Doing acc with" Var,
  Ctx => acc Var,
  print "SUCCESS !!".

% the syntax `acc ?-` is used to load acc1 clauses as hypothesis in the context
constraint acc1 ?- p trig {
  rule \ trig (Ctx ?- p A) | (std.mem! Ctx (acc 2)) <=> (Ctx => (acc 2, acc1 A)).
}

% this extends the previous constraint
constraint acc ?- p trig {
  rule \ trig (Ctx ?- p A) <=> (Ctx => (acc A, acc1 A)).
}

% here again `acc ?-` is used but the clique error message is not thrown, since,
% again `acc` is loaded and supposed to be only used as hypotheses in the context
constraint acc ?- q trig1 {
  rule trig1 \ (Ctx ?- q A) <=> (tester "q" Ctx A).
  rule \ trig1.
}

pred q&trig1.
q&trig1 :-
  (acc 4 =!=> declare_constraint (q 4) [_]), declare_constraint trig1 [_],
  (acc 4 =!=> declare_constraint (q 5) [_]), not (declare_constraint trig1 [_]).

pred p&trig.
p&trig :-
  (acc 3 =!=> acc1 3 =!=> declare_constraint (p 3) [_]), declare_constraint trig [_],
  (acc 4 =!=> acc1 5 =!=> declare_constraint (p 4) [_]), not (declare_constraint trig [_]), 
  (acc 2 =!=> acc1 4 =!=> declare_constraint (p 4) [_]), declare_constraint trig [_].

main :-
  p&trig, q&trig1.