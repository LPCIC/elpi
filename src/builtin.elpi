% File generated by elpi -document-builtins, do not edit

%  == Core builtins =====================================

%  -- Logic --

pred true.

true.

pred fail.

pred false.

pred (=) o:A, o:A.

X = X.

pred (;) o:prop, o:prop.

(A ; _) :- A.

(_ ; B) :- B.

type (:-) prop -> prop -> prop.

type (:-) prop -> list prop -> prop.

type (,) variadic prop prop.

type uvar A.

type (as) A -> A -> A.

type (=>) prop -> prop -> prop.

type (=>) list prop -> prop -> prop.

%  -- Control --

external pred !. % The cut operator

pred not i:prop.

not X :- X, !, fail.

not _.

% [declare_constraint C Keys] declares C with Keys (a list of variables).
external pred declare_constraint i:any, i:list any.

external pred print_constraints. % prints all constraints

% [halt ...] halts the program and print the terms
external type halt variadic any prop.

pred stop.

stop :- halt.

%  -- Evaluation --

% [calc Expr Out] unifies Out with the value of Expr. It can be used in
% tandem with spilling, eg [f {calc (N + 1)}]
external pred calc i:A, o:A.

pred (is) o:A, i:A.

X is Y :- calc Y X.

type (-) A -> A -> A.

type (^) string -> string -> string.

type (+) int -> int -> int.

type (+) float -> float -> float.

type (*) int -> int -> int.

type (*) float -> float -> float.

%  -- Arithmetic tests --

% [lt_ X Y] checks if X < Y. Works for string, int and float
external pred lt_ i:A, i:A.

% [gt_ X Y] checks if X > Y. Works for string, int and float
external pred gt_ i:A, i:A.

% [le_ X Y] checks if X =< Y. Works for string, int and float
external pred le_ i:A, i:A.

% [ge_ X Y] checks if X >= Y. Works for string, int and float
external pred ge_ i:A, i:A.

type (<), (>), (=<), (>=) A -> A -> prop.

X  > Y  :- gt_ X Y.

X  < Y  :- lt_ X Y.

X  =< Y :- le_ X Y.

X  >= Y :- ge_ X Y.

type (i<), (i>), (i=<), (i>=) int -> int -> prop.

X i< Y  :- lt_ X Y.

X i> Y  :- gt_ X Y.

X i=< Y :- le_ X Y.

X i>= Y :- ge_ X Y.

type (r<), (r>), (r=<), (r>=) float -> float -> prop.

X r< Y  :- lt_ X Y.

X r> Y  :- gt_ X Y.

X r=< Y :- le_ X Y.

X r>= Y :- ge_ X Y.

type (s<), (s>), (s=<), (s>=) string -> string -> prop.

X s< Y  :- lt_ X Y.

X s> Y  :- gt_ X Y.

X s=< Y :- le_ X Y.

X s>= Y :- ge_ X Y.

%  -- Standard data types (supported in the FFI) --

kind list type -> type.

type (::) X -> list X -> list X.

type ([]) list X.

% Boolean values: tt and ff since true and false are predicates
kind bool type.
type tt bool.
type ff bool.

% Pair: the constructor is pr, since ',' is for conjunction
kind pair type -> type -> type.
type pr A -> B -> pair A B.

pred fst  i:pair A B, o:A.

fst (pr A _) A.

pred snd  i:pair A B, o:B.

snd (pr _ B) B.

% The option type (aka Maybe)
kind option type -> type.
type none option A.
type some A -> option A.

%  == I/O builtins =====================================

%  -- I/O --

macro @in_stream :- ctype "in_stream".

type std_in @in_stream.

macro @out_stream :- ctype "out_stream".

type std_out @out_stream.
type std_err @out_stream.

% [open_in FileName InStream] opens FileName for input
external pred open_in i:string, o:@in_stream.

% [open_out FileName OutStream] opens FileName for output
external pred open_out i:string, o:@out_stream.

% [open_append FileName OutStream] opens FileName for output in append mode
external pred open_append i:string, o:@out_stream.

% [close_in InStream] closes input stream InStream
external pred close_in i:@in_stream.

% [close_out OutStream] closes output stream OutStream
external pred close_out i:@out_stream.

% [output OutStream Data] writes Data to OutStream
external pred output i:@out_stream, i:string.

% [flush OutStream] flush all output not yet finalized to OutStream
external pred flush i:@out_stream.

% [input InStream Bytes Data] reads Bytes from InStream
external pred input i:@in_stream, i:int, o:string.

% [input_line InStream Line] reads a full line from InStream
external pred input_line i:@in_stream, o:string.

% [eof InStream] checks if no more data can be read from InStream
external pred eof i:@in_stream.

%  -- System --

% [gettimeofday T] sets T to the number of seconds elapsed since 1/1/1970
external pred gettimeofday o:float.

% [getenv VarName Value] Like Sys.getenv
external pred getenv i:string, o:option string.

% [system Command RetVal] executes Command and sets RetVal to the exit code
external pred system i:string, o:int.

%  -- Debugging --

% [term_to_string T S] prints T to S
external pred term_to_string i:any, o:string.

% == Lambda Prolog builtins =====================================

%  -- Extra I/O --

% [open_string DataIn InStream] opens DataIn as an input stream
external pred open_string i:string, o:@in_stream.

% [lookahead InStream NextChar] peeks one byte from InStream
external pred lookahead i:@in_stream, o:string.

%  -- Hacks --

% [string_to_term S T] parses a term T from S
external pred string_to_term i:string, o:any.

% [readterm InStream T] reads T from InStream
external pred readterm i:@in_stream, o:any.

pred printterm i:@out_stream, i:A.

printterm S T :- term_to_string T T1, output S T1.

pred read o:A.

read S :- flush std_out, input_line std_in X, string_to_term X S.

% == Elpi builtins =====================================

% [dprint ...] prints raw terms (debugging)
external type dprint variadic any prop.

% [print ...] prints terms
external type print variadic any prop.

% [counter Name Value] reads the Value of a trace point Name
external pred counter i:string, o:int.

% [rex_match Rex Subject] checks if Subject matches Rex. Matching is based
% on OCaml's Str library
external pred rex_match i:string, i:string.

% [rex_replace Rex Replacement Subject Out] Out is obtained by replacing all
% occurrences of Rex with Replacement in Subject. See also OCaml's
% Str.global_replace
external pred rex_replace i:string, i:string, i:string, o:string.

% [quote_syntax FileName QueryText QuotedProgram QuotedQuery] quotes the
% program from FileName and the QueryText. See elpi-quoted_syntax.elpi for
% the syntax tree
external pred quote_syntax i:string, i:string, o:list A, o:A.

% == Elpi nonlogical builtins =====================================

% Opaque ML data types
kind ctype type.
type ctype string -> ctype.

% [var any term] checks if the term is a variable
external pred var i:any.

% [same_var first term second term] checks if the two terms are the same
% variable
external pred same_var i:A, i:A.

% [name T ...] checks if T is a eigenvariable. When used with tree arguments
% it relates an applied name with its head and argument list.
external type name any -> variadic any prop.

% [constant T ...] checks if T is a (global) constant.  When used with tree
% arguments it relates an applied constant with its head and argument list.
external type constant any -> variadic any prop.

external pred names % generates the list of eigenvariable
  o:list any. % list of eigenvariables in order of age (young first)
  
external pred occurs % checks if the constant occurs in the term
  i:A, % a constant (global or eigenvariable)
  i:A. % a term
  
% [closed_term T] unify T with a variable that has no eigenvariables in
% scope
external pred closed_term o:any.

% [is_cdata T Ctype] checks if T is primitive of type Ctype, eg (ctype
% "int")
external pred is_cdata i:any, o:ctype.

pred primitive? i:A, i:string.

primitive? X S :- is_cdata X (ctype S).

% [new_int N] unifies N with a different int every time it is called
external pred new_int o:int.

% Holds data across bracktracking
macro @safe :- ctype "safe".


% [new_safe Safe] creates a safe: a store that persists across backtracking
external pred new_safe o:@safe.

% [stash_in_safe Safe Data] stores Data in the Safe
external pred stash_in_safe i:@safe, i:any.

% [open_safe Safe Data] retrieves the Data stored in Safe
external pred open_safe i:@safe, o:list any.


% [if C T E] picks the first success of C then runs T (never E).
% if C has no success it runs E.
pred if i:prop, i:prop, i:prop.
if B T _ :- B, !, T.
if _ _ E :- E.  

% [random.init Seed] Initialize OCaml's PRNG with the given Seed
external pred random.init i:int.

% [random.self_init] Initialize OCaml's PRNG with some seed
external pred random.self_init .

% [random.int Bound N] unifies N with a random int between 0 and Bound
% (excluded)
external pred random.int i:int, o:int.



% == stdlib =======================================================

% Conventions:
% - all predicates declare a mode with some input arguments, unless...
% - predicates whose name ends with R are relations (work in any direction,
%   that is all arguments are in ouput mode)
% - predicates whose name ends with ! do contain a cut and generate only the
%   first result
% - all errors given by this library end up calling fatal-error[-w-data],
%   override it in order to handle them differently
% - all debug prints by this library end up calling debug-print, override it
%   in order to handle them differently

namespace std {

pred fatal-error i:string.
:name "default-fatal-error"
fatal-error Msg :- halt Msg.

pred fatal-error-w-data i:string, i:A.
:name "default-fatal-error-w-data"
fatal-error-w-data Msg Data :- halt Msg ":" Data.

pred debug-print i:string, i:A.
:name "default-debug-print"
debug-print Msg Data :- print Msg Data.

%  -- Errors, Debugging, Hacks --

pred ignore-failure! i:prop.
ignore-failure! P :- P, !.
ignore-failure! _.

% [assert! C M] takes the first success of C or fails with message M 
pred assert! i:prop, i:string.
assert! Cond Msg :- (Cond ; fatal-error-w-data Msg Cond), !.

% [spy P] traces the call to P, printing all success and the final failure
pred spy i:prop.
spy P :- counter "run" NR, if (not(NR = 0)) (debug-print "run=" NR) true,
         debug-print "----<<---- enter: " P,
         P,
         debug-print "---->>---- exit: " P.
spy P :- debug-print "---->>---- fail: " P, fail.

% [spy! P] traces the first call to P without leaving a choice point
pred spy! i:prop.
spy! P :- counter "run" NR, if (not(NR = 0)) (debug-print "run=" NR) true,
         debug-print "----<<---- enter: " P,
         P,
         debug-print "---->>---- exit: " P, !.
spy! P :- debug-print "---->>---- fail: " P, fail.

% to silence the type checker
pred unsafe-cast o:A, o:B.
unsafe-cast X X.

% -- List processing --

pred length i:list A, o:int.
length [_|L] N :- length L N1, N is N1 + 1.
length []    0.

pred rev i:list A, o:list A.
rev L RL  :- rev.aux L []  RL.
rev.aux [X|XS] ACC R :- rev.aux XS [X|ACC] R.
rev.aux [] L L.

pred last i:list A, o:A.
last [] _ :- fatal-error "last on empty list".
last [X] X :- !.
last [_|XS] R :- last XS R.

pred append i:list A, i:list A, o:list A.
append [X|XS] L [X|L1] :- append XS L L1 .
append [] L L .

pred appendR o:list A, o:list A, o:list A.
appendR [X|XS] L [X|L1] :- appendR XS L L1 .
appendR [] L L .

pred take i:int, i:list A, o:list A.
take 0 _ [] :- !.
take N [X|XS] [X|L] :- !, N1 is N - 1, take N1 XS L.
take _ _ _ :- fatal-error "take run out of list items".

pred drop i:int, i:list A, o:list A.
drop 0 L L :- !.
drop N [_|XS] L :- !, N1 is N - 1, drop N1 XS L.
drop _ _ _ :- fatal-error "drop run out of list items".

pred drop-last i:int, i:list A, o:list A.
drop-last N L R :-
  length L M, I is M - N, take I L R.

pred split-at i:int, i:list A, o:list A, o:list A.
split-at 0 L [] L :- !.
split-at N [X|XS] [X|LN] LM :- !, N1 is N - 1, split-at N1 XS LN LM.
split-at _ _ _ _ :- fatal-error "split-at run out of list items".

pred fold i:list B, i:A, i:(B -> A -> A -> prop), o:A.
fold [] A _ A.
fold [X|XS] A F R :- F X A A1, fold XS A1 F R.

pred fold2 i:list C, i:list B, i:A, i:(C -> B -> A -> A -> prop), o:A.
fold2 [] [_|_] _ _ _ :- fatal-error "fold2 on lists of different length".
fold2 [_|_] [] _ _ _ :- fatal-error "fold2 on lists of different length".
fold2 [] [] A _ A.
fold2 [X|XS] [Y|YS] A F R :- F X Y A A1, fold2 XS YS A1 F R.

pred map i:list A, i:(A -> B -> prop), o:list B.
map [] _ [].
map [X|XS] F [Y|YS] :- F X Y, map XS F YS.

pred map-i i:list A, i:(int -> A -> B -> prop), o:list B.
map-i L F R :- map-i.aux L 0 F R.
map-i.aux [] _ _ [].
map-i.aux [X|XS] N F [Y|YS] :- F N X Y, M is N + 1, map-i.aux XS M F YS.

:index(1 1)
pred map2 i:list A, i:list B, i:(A -> B -> C -> prop), o:list C.
map2 [] [_|_] _ _ :- fatal-error "map2 on lists of different length".
map2 [_|_] [] _ _ :- fatal-error "map2 on lists of different length".
map2 [] [] _ [].
map2 [X|XS] [Y|YS] F [Z|ZS] :- F X Y Z, map2 XS YS F ZS.

pred map2_filter i:list A, i:list B, i:(A -> B -> C -> prop), o:list C.
map2_filter [] [_|_] _ _ :- fatal-error "map2_filter on lists of different length".
map2_filter [_|_] [] _ _ :- fatal-error "map2_filter on lists of different length".
map2_filter [] [] _ [].
map2_filter [X|XS] [Y|YS] F [Z|ZS] :- F X Y Z, !, map2_filter XS YS F ZS.
map2_filter [_|XS] [_|YS] F ZS :- map2_filter XS YS F ZS.

% [nth N L X] picks in X the N-th element of L (L must be of length > N)
pred nth i:int, i:list A, o:A.
nth 0 [X|_] X :- !.
nth N [_|XS] R :- !, N1 is N - 1, nth N1 XS R.
nth _ _ _ :- fatal-error "nth run out of list items".

% [lookup L K V] sees L as a map from K to V
pred lookup i:list (pair A B), i:A, o:B.
lookup [pr X Y|_] X Y.
lookup [_|LS]       X Y :- lookup LS X Y.

% [lookup! L K V] sees L as a map from K to V, stops at the first binding
pred lookup! i:list (pair A B), i:A, o:B.
lookup! [pr X Y|_] X Y :- !.
lookup! [_|LS]       X Y :- lookup! LS X Y.

% [mem! L X] succeeds once if X occurs inside L 
pred mem! i:list A, o:A.
mem! [X|_] X :- !.
mem! [_|L] X :- mem! L X.

% [mem L X] succeeds every time if X occurs inside L 
pred mem i:list A, o:A.
mem [X|_] X.
mem [_|L] X :- mem L X.


pred exists i:list A, i:(A -> prop).
exists [X|_] P :- P X.
exists [_|L] P :- exists L P.

pred exists2 i:list A, i:list B, i:(A -> B -> prop).
exists2 [] [_|_] _ :- fatal-error "exists2 on lists of different length".
exists2 [_|_] [] _ :- fatal-error "exists2 on lists of different length".
exists2 [X|_] [Y|_] P :- P X Y.
exists2 [_|L] [_|M] P :- exists2 L M P.

pred forall i:list A, i:(A -> prop).
forall [] _.
forall [X|L] P :- P X, forall L P.

pred forall2 i:list A, i:list B, i:(A -> B -> prop).
forall2 [] [_|_] _ :- fatal-error "forall2 on lists of different length".
forall2 [_|_] [] _ :- fatal-error "forall2 on lists of different length".
forall2 [X|XS] [Y|YS] P :- P X Y, forall2 XS YS P.
forall2 [] [] _.

pred filter i:list A, i:(A -> prop), o:list A.
filter []    _ [].
filter [X|L] P R :- if (P X) (R = X :: L1) (R = L1), filter L P L1.

pred zip i:list A, i:list B, o:list (pair A B).
zip [_|_] [] _ :- fatal-error "zip on lists of different length".
zip [] [_|_] _ :- fatal-error "zip on lists of different length".
zip [X|LX] [Y|LY] [pr X Y|LR] :- zip LX LY LR.
zip [] [] [].

pred unzip i:list (pair A B), o:list A, o:list B.
unzip [] [] [].
unzip [pr X Y|L] [X|LX] [Y|LY] :- unzip L LX LY.

pred flatten i:list (list A), o:list A.
flatten [X|LS] R :- flatten LS LS', append X LS' R.
flatten []     [].

pred null i:list A.
null [].

pred iota i:int, o:list int.
iota N L :- iota.aux 0 N L.
iota.aux X X [] :- !.
iota.aux N X [N|R] :- M is N + 1, iota.aux M X R.

%  -- Misc --

pred flip i:(A -> B -> prop), i:B, i:A.
flip P X Y :- P Y X.

pred time i:prop, o:float.
time P T :- gettimeofday Before, P, gettimeofday After, T is After - Before.

pred do! i:list prop.
do! [].
do! [P|PS] :- P, !, do! PS.

pred spy-do! i:list prop.
spy-do! L :- map L (x\y\y = spy x) L1, do! L1.

pred any->string i:A, o:string.
any->string X Y :- term_to_string X Y.

} % namespace std 




