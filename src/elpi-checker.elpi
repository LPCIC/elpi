/* elpi: embedded lambda prolog interpreter                                  */
/* license: GNU Lesser General Public License Version 2.1 or later           */
/* ------------------------------------------------------------------------- */

% Simple type checker for lambda-Prolog programs
accumulate elpi-quoted_syntax.

% --------- HOAS or programs  ------------------------------------------------

kind typ type. %%%%% types %%%%%%

type arrow typ -> typ -> typ.
type tconst string -> typ.
type tapp list typ -> typ.
type prop typ.
type forall (typ -> typ) -> typ. % polymorphic type declarations
type ctype string -> typ.

% --------- utils  ---------------------------------------------------------
% CAVEAT: this runs without any std library

pred if i:prop, i:prop, i:prop.
if B T _ :- B, !, T.
if _ _ E :- E.

pred mem i:list A, i:A.
mem [X|_] X :- !.
mem [_|L] X :- mem L X.

pred mem-assoc i:list entry, i:term.
mem-assoc [X `: _ | _] X :- !.
mem-assoc [ _ | XS] X :- mem-assoc XS X.

pred rev i:list A, o:list A.
rev L RL  :- rev.aux L []  RL.
rev.aux [X|XS] ACC R :- rev.aux XS [X|ACC] R.
rev.aux [] L L.

pred iter i:(A -> prop), i:list A.
iter _ [].
iter F [X | XS] :- F X, iter F XS.

kind pair type -> type -> type.
type pr   A -> B -> pair A B.
pred fst  i:pair A B, o:A.
fst (pr A _) A.

pred snd  i:pair A B, o:B.
snd (pr _ B) B.

% --------- error reporting  ------------------------------------------------
kind err type.
type type-err term -> typ -> typ -> err.
type wrong-arity term -> typ -> list term -> err.
type unknown term -> err.
type assert prop -> err -> prop.

type error list (pair (ctype "Loc.t") string) -> bool -> prop.

:name "default-typechecking-error"
error Msg tt :- iter (x\ sigma L M\ fst x L, snd x M, print L "Error:" M) Msg.

type warning (ctype "Loc.t") -> string -> prop.
:name "default-typechecking-warning"
warning Loc Msg :- print Loc "Warning:" Msg.

assert P _ :- P, !.
assert _ (type-err T Ty ETy) :- !,
  checking LOC,
  MSG is {pp T} ^ " has type " ^ {ppt Ty} ^
         " but is used with type " ^ {ppt ETy},
  error [pr LOC MSG] _.
assert _ (wrong-arity T Ty A) :- !,
  checking LOC,
  MSG is {pp T} ^ " has type " ^ {ppt Ty} ^
          " but is applied to " ^ {pp-list A},
  error [pr LOC MSG] _.

stash-new E S :- open_safe E L, ( mem L S ; stash_in_safe E S ), !.

report-all-failures-if-no-success P RC :-
  new_safe E,
  (((pi ML\ error ML _ :- !, iter (stash-new E) ML, fail) => P)
   ;
   (error {open_safe E} RC)).
report-all-failures-and-fail-if-no-success P RC :-
  new_safe E,
  (((pi ML\ error ML _ :- !, iter (stash-new E) ML, fail) => P)
   ;
   (error {open_safe E} RC, fail)).

mode (pp i o).
type pp term -> string -> prop.
pp (app L) T1 :- !, pp-list L T, T1 is "(" ^ T ^ ")".
pp (lam F) T :- !, pi x\ term_to_string x XS, (pp x XS :- !) => pp (F x) T.
pp (const "discard") "_" :- !.
pp (const S) S :- !.
pp (cdata X) S :- !, term_to_string X S.
pp X XS :- term_to_string X XS.

mode (pp-list i o).
pp-list [X] Y :- !, pp X Y.
pp-list [X|XS] Y :- pp-list XS XSS, pp X XT, Y is XT ^ " " ^ XSS.
pp-list [] "".

mode (ppt i o).
ppt (ctype X) X :- !.
ppt (tconst X) X :- !.
ppt (tapp L) X :- !, ppt-list L T, X is "(" ^ T ^ ")".
ppt (arrow A B) S :- !, ppt A AS, ppt B BS, S is "(" ^ AS ^ " -> " ^ BS ^ ")".
ppt X Y :- term_to_string X Y.

mode (ppt-list i o).
ppt-list [X] Y :- !, ppt X Y.
ppt-list [X|XS] Y :- ppt-list XS XSS, ppt X XT, Y is XT ^ " " ^ XSS.
ppt-list [] "".

% --------- typing  -------------------------------------------------------

mode (unif i i).

unif (tconst "any") _ :- !.
unif _ (tconst "any") :- !.
unif (tapp [tconst "variadic",_,X]) Y :- unif X Y.
unif Y (tapp [tconst "variadic",_,X]) :- unif Y X.
unif (tapp []) (tapp []).
unif (tapp [X|L1]) (tapp [Y|L2]) :- unif X Y, unif (tapp L1) (tapp L2).
unif (tconst X) (tconst X).
unif (ctype X) (ctype X).
unif prop prop.
unif (arrow A1 B1) (arrow A2 B2) :- unif A1 A2, unif B1 B2.
unif (uvar as X) Y :- X = Y.
unif Y (uvar as X) :- X = Y.

mode (of i o).

of (cdata CData) Ty :-
  is_cdata CData (ctype CTy), !,
  assert (unif Ty (ctype CTy)) (type-err (cdata CData) (ctype CTy) Ty).

of (app [HD|ARGS]) TY :- !, 
  report-all-failures-if-no-success % HD may have multiple types
   (of HD HDTY, of-app HDTY ARGS TY HD (Done - Done), !) _.
of (lam F) (arrow T B) :- !, pi x\
  (of x T :- !) => of (F x) B.

mode (of-app i i o o o).

:if "DEBUG:CHECKER"
of-app Ty Args Tgt Hd _ :-
  print {counter "run"} "of-app" {pp Hd} ":" {ppt Ty} "@" {pp-list Args} "=" {ppt Tgt}, fail.

of-app (tapp [tconst "variadic", T, _] as V) [X|XS] TGT HD (B - BT) :- !,
  of X TX, assert (unif T TX) (type-err X TX T), BT = X :: TL, of-app V XS TGT HD (B - TL).
of-app (tapp [tconst "variadic", _, TS]) [] TGT HD (D - []) :- !,
  assert (unif TGT TS) (type-err (app [HD|D]) TS TGT).
of-app (arrow T TS) [X|XS] TGT HD (B - BT) :- !,
  of X TX, assert (unif T TX) (type-err X TX T), BT = X :: TL, of-app TS XS TGT HD (B - TL).
of-app (uvar as ARR)  [X|XS] TGT HD (B - BT) :- !,
  of X T, ARR = arrow T TS, BT = X :: TL, of-app TS XS TGT HD (B - TL).
of-app Ty [] TGT HD (D - []) :- !,
  assert (unif TGT Ty) (type-err (app [HD|D]) Ty TGT).
of-app (uvar as Ty)  [] TGT HD (D - []) :- !,
  assert (unif TGT Ty) (type-err (app [HD|D]) Ty TGT).

of-app Ty Args _ HD (D - []) :- !,
  assert false (wrong-arity (app [HD|D]) Ty Args).

of-clause [N|NS] (arg C) :- !, pi x\ 
 (pp x N :- !) => (pi Tf\ of x Tf :- !, assert (unif T Tf) (type-err x T Tf)) =>
 of-clause NS (C x).
of-clause [] (arg C) :- !, pi x\ 
 (pi Tf\ of x Tf :- !, assert (unif T Tf) (type-err x T Tf)) =>
 of-clause [] (C x).
of-clause _ C :- of C TC, assert (unif TC prop) (type-err C TC prop).

type checking (ctype "Loc.t") -> prop.

:if "DEBUG:CHECKER"
log-tc-clause Loc Query :- !, print {counter "run"} "typecheck" Loc Query.
log-tc-clause _ _.

typecheck [] (clause Loc Names Query) RC :-
  log-tc-clause Loc Query,
  checking Loc =>
    report-all-failures-if-no-success (of-clause Names Query) RC.
typecheck [ (clause Loc Names Clause) |Rest] Q RC :-
  log-tc-clause Loc Clause,
  checking Loc =>
    report-all-failures-if-no-success (of-clause Names Clause) RC, !,
  typecheck Rest Q RC.

mode (refresh i o).
refresh (forall F) T :- !, refresh (F FRESH_) T.
refresh (tconst "any") FRESH_ :- !.
refresh X X.

safe-dest-app (app [X | A]) X A :- !.
safe-dest-app X X [].

collect-symbols-term N _ X X :- name N, !.
collect-symbols-term (cdata _) _ X X :- !.
collect-symbols-term (app []) _ X X :- !.
collect-symbols-term (app [HD|L]) Known Acc Res :- !,
  collect-symbols-term HD Known Acc Acc1,
  collect-symbols-term (app L) Known Acc1 Res.
collect-symbols-term (lam F) Known Acc Res :- !,
  pi x\ collect-symbols-term (F x) Known Acc Res.
collect-symbols-term (arg F) Known Acc Res :- !,
  pi x\ collect-symbols-term (F x) Known Acc Res.
collect-symbols-term (const _ as C) Known Acc Res :- !,
  if (mem-assoc Known C; mem-assoc Acc C) (Res = Acc) (checking Loc, Res = [C `: Loc | Acc]).

collect-symbols-clause (clause Loc _ C) Known Acc Res :-
  checking Loc => collect-symbols-term C Known Acc Res.

collect-symbols-program [ C | P ] Known Acc Res :-
  collect-symbols-clause C Known Acc Acc1,
  collect-symbols-program P Known Acc1 Res.
collect-symbols-program [] _ X X.

mode (under-env i i).

type known term -> prop.

similar S1 S2 :-
  R is ".*\\." ^ S2,
  rex_match R S1.

filter-similar [] _ [].
filter-similar [const K `: _ |KS] S [K|R] :- similar K S, !, filter-similar KS S R.
filter-similar [_|KS] S R :- filter-similar KS S R.

pred str_concat i:list string, o:string.
str_concat [] "".
str_concat [S|SS] R :- str_concat SS RR, R is S ^ " " ^ RR.

warn-undeclared Known ((const "main") `: _) :- !.
warn-undeclared Known ((const S) `: _) :- rex_match ".*\\.aux" S, !.
warn-undeclared Known ((const S) `: _) :- rex_match ".*\\.aux\\." S, !.
warn-undeclared Known ((const S) `: LOC) :-
  filter-similar Known S Hints,
  if (Hints = []) (H = "") (H is " Did you mean " ^ {str_concat Hints} ^ "?"),
  MSG is "constant " ^ S ^ " has no declared type." ^ H,
  warning LOC MSG.

type (`:) term -> typ -> entry.
type (`:) term -> ctype "Loc.t" -> entry.

under-decl-env [] P :- P.
under-decl-env [ X `: PT | XS ] P :-
  %print "Assume" X PT,
  (pi Ty\ of X Ty :- refresh PT Ty) => known X => under-decl-env XS P.

under-undecl-env [] P :- P.
under-undecl-env [ X `: _ | XS ] P :-
  %print "Assume" X PT,
  (of X Ty_ :- !) => under-undecl-env XS P.

typecheck-program P Q DeclaredTypes RC :-
  KnownTypes = [
    ((const "pi") `: forall x\ (arrow (arrow x prop) prop)),
    ((const "sigma") `: forall x\ (arrow (arrow x prop) prop)),
    ((const "discard") `: forall x\ x)|DeclaredTypes],
  collect-symbols-program P KnownTypes [] TMP,
  collect-symbols-clause Q KnownTypes TMP Undeclared,
  iter (warn-undeclared KnownTypes) {rev Undeclared},
  under-decl-env {rev KnownTypes}
      (under-undecl-env Undeclared (typecheck P Q RC)).

% ---------- warnings ------------------------------------------------------

type `-> term -> int -> entry.
type variable term -> prop.

mode (report-linear i).
report-linear [].
report-linear [V `-> 1 + uvar |NS] :- !,
  pp V VN,
  if (not(rex_match "_" VN), not(rex_match ".*_" VN))
    (checking LOC,
     MSG is VN ^" is linear: name it _" ^ VN ^
         " (discard) or " ^ VN ^ "_ (fresh variable)",
     warning LOC MSG)
    true,
  report-linear NS.
report-linear [V `-> uvar |NS] :-
  pp V VN,
  if (not(rex_match "_" VN), not(rex_match ".*_" VN))
    (checking LOC, MSG is VN ^" is unused", warning LOC MSG)
    true,
  report-linear NS.
report-linear [_ `-> _ | NS] :- report-linear NS.

type count A -> list B -> prop.
count (lam F) E :- pi x\ count (F x) E.
count (app [X|XS]) E :- !, count X E, count (app XS) E.
count (app []) _ :- !.
count X E :- variable X, !, incr X E.
count A _.

mode (incr i i).
incr X [X `-> K | _] :- add1 K.
incr X [_ | XS] :- incr X XS.

mode (add1 i).
add1 (uvar as K) :- K = 1 + FRESH_.
add1 (1 + K) :- add1 K.

check-non-linear [N|NS] (arg C) L :- pi x\
 (pp x N :- !) => (variable x) => check-non-linear NS (C x) [x `-> FRESH_ | L].
check-non-linear [] (arg C) L :- pi x\
 (variable x) => check-non-linear NS (C x) [x `-> FRESH_ | L].
check-non-linear _ C L :-
  count C L, report-linear L.

warn-linear [].
warn-linear [ (clause Loc Names Clause) |CS] :-
  checking Loc =>  check-non-linear Names Clause [],
  warn-linear CS.

% ---------- test ----------------------------------------------------------

main.

% ------- entry ---------------------------------------

check P Q DeclaredTypes :-
  typecheck-program P Q DeclaredTypes RC, !,
  warn-linear P, !,
  if (var RC) (true) (fail).

% vim: set ft=lprolog:
