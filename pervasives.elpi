%%%%%%%%%%%%%% PREDICATES NOT IMPLEMENTED/DOCUMENTED IN TEYJUS %%%%%%%%%%%%%%%%

%open_socket
%time
%solve

%%%%%%%%%%%%%%%%%% DECLARATION OF CUSTOM PREDICATES %%%%%%%%%%%%%%%%%%%%%%%%%%%

% nofixity !
% nofixity sigma
% nofixity pi
% nofixity true
% nofixity fail

% nofixity nil

% nofixity abs               nofixity iabs         nofixity rabs
% nofixity int_to_real
% nofixity sqrt
% nofixity sin
% nofixity cos
% nofixity arctan
% nofixity ln
% nofixity floor
% nofixity ceil
% nofixity truncate
% nofixity size
% nofixity chr
% nofixity string_to_int
% nofixity substring
% nofixity real_to_string
% nofixity int_to_string
% nofixity std_in
% nofixity std_out
% nofixity std_err

% NOT IN TEYJUS
% nofixity $print
% nofixity $lt
% nofixity is_flex
% nofixity $print_delayed

% nofixity propagate
% nofixity $delay
% nofixity nabla
% nofixity $closed

% nofixity $dprint

% nofixity $gettimeofday

prefix ~  256.       prefix i~  256.     prefix r~  256.
infixl mod 160.
infixl div 160.
infixl *  160.       infixl i*  160.     infixl r*  160.
infixl /  160.
infixl ^  150.
infixl +  150.       infixl i+  150.     infixl r+  150.
infixl -  150.       infixl i-  150.     infixl r-  150.
infixr :: 140.
infix  @  135.
infix  >  130.       infix  i>  130.     infix  r>  130.     infix  s>  130.
infix  <  130.       infix  i<  130.     infix  r<  130.     infix  s<  130.
infix  >= 130.       infix  i>= 130.     infix  r>= 130.     infix  s>= 130.
infix  =< 130.       infix  i=< 130.     infix  r=< 130.     infix  s=< 130.
infix  =  130.
infix  := 130.
infix  is 130.
infixr as 129.
infixr => 129.
infixr &  120.
infix  ?- 115.
infixr ,  110.
infixr ;  100.
infixl :- 0.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%% CUSTOM PREDICATES %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

X  < Y  :- $lt_ X Y.
X i< Y  :- $lt_ X Y.
X r< Y  :- $lt_ X Y.
X s< Y  :- $lt_ X Y.

X  > Y  :- $gt_ X Y.
X i> Y  :- $gt_ X Y.
X r> Y  :- $gt_ X Y.
X s> Y  :- $gt_ X Y.

X  =< Y :- $le_ X Y.
X i=< Y :- $le_ X Y.
X r=< Y :- $le_ X Y.
X s=< Y :- $le_ X Y.

X  >= Y :- $ge_ X Y.
X i>= Y :- $ge_ X Y.
X r>= Y :- $ge_ X Y.
X s>= Y :- $ge_ X Y.

getenv X Y :- $getenv X Y.
system X Y :- $system X Y.
X is Y :- $is X Y.
open_in X Y :- $open_in X Y.
open_out X Y :- $open_out X Y.
open_append X Y :- $open_append X Y.
open_string X Y :- $open_string X Y.
close_in X :- $close_in X.
close_out X :- $close_out X.
output X Y :- $output X Y.
term_to_string X Y :- $term_to_string X Y.
string_to_term X Y :- $string_to_term X Y.
flush X :- $flush X.
halt :- $halt.
input X Y Z :- $input X Y Z.
input_line X Y :- $input_line X Y.
readterm X Y :- $readterm X Y.
lookahead X Y :- $lookahead X Y.
eof X :- $eof X.
is_flex X :- $is_flex X. % is_flex X :- not (not (X = x_unused_x))
                         % does not work with delay/propagate
                         % because the predicate is not "reentrant"
                         % (i.e. when X <- x_unused_x occurs, it may
                         % resume a goal that checks again is_flex X
                         % returning true in place of false!

level X Y :- $level X Y. % Y = level of constant X
                         % Y < 0 if X is global, 0 <= Y if X is local
                         % fails if X is not a constant

occurs X Y :- $occurs X Y. % if X is a constant,
                           % succeeds if X occurs in X

%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PREDEFINED PREDICATES %%%%%%%%%%%%%%%%%%%%%%%

true.

X = X.

(A ; _B) :- A.
(_A ; B) :- B.

not X :- X, !, fail.
not _X.

printterm S T :- term_to_string T T', output S T'.

print S :- output std_out S.

read S :- flush std_out, input_line std_in X, string_to_term X S.

stop :- halt.

time T :- $gettimeofday B, T, $gettimeofday A, D is A - B, $print "TIME" D T.

type $$=   X -> X -> prop.
type $$::  X -> list X -> list X.
type $$[]  list X.
type $$is  X -> X -> prop.
type $$$term_to_string X -> string -> prop.
type $$$print X -> Y.
type $$:- prop -> prop -> prop.
type $$, prop -> Y.
type $$?? A.
type $$as A -> A -> A.
type $$$constraint A -> B -> prop.
type $$$gettimeofday float -> prop.
type $$$counter string -> int -> prop.
type $$- A -> A -> A.
